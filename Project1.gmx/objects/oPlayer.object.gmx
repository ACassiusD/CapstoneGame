<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>oParEntity</parentName>
  <maskName>sPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables

// Inherit oParEntity variables
event_inherited();

facing = 1;

// Movement ///////////////////////////////////////////////////////////////////

groundAccel = 1.20;
slideFric   = 0.60
groundFric  = 1.00;
airAccel    = 0.75;
airFric     = 0.10;
vxMax       = 10.00;
vyMax       = 10.00;
jumpHeight  = 12.00;
gravNorm    = 0.80;
gravSlide   = 0.25; 

clingTime   = 6.0;

throwTime   = 100;

jumpCount = 2;

dashOnCD = false;

// Misc ///////////////////////////////////////////////////////////////////////

// States
IDLE     = 10;
RUN      = 11;
JUMP     = 12;
ROLL     = 13;
DASH     = 14;

// Initialize properties
state  = IDLE;
facing = image_xscale; // Change xscale in editor to adjust initial facing

// For squash + stretch
xscale = 1;
yscale = 1;

///////////////////////////////////////////////////////////////////////////////

attacking = false;
blocking  = false;

//fallTime = 0;
//fallMax  = 28;

kunai = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_exists(oDeathCounter))
{
    global.deaths++
}
show_debug_message("Death");
instance_create(0, 0, oFxRoomRestart);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(instance_exists(oAbilityKunai)){
                
    if (kunai.speed &gt; 0)
    {
        with (oAbilityKunai)
           {
                instance_destroy();
           }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>state = IDLE;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dashOnCD = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Roll slash
attacking = false;
state     = IDLE; // ?
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sticking = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Entity Step 2.0

/// EntityStep();

jumped = false;
landed = false;

if (vy &lt; 1 &amp;&amp; vy &gt; -1)
    PlatformCheck();
else
    repeat(abs(vy)) {
        if (!PlatformCheck())
            y += sign(vy);
        else
            break;
    }

if (platformTarget) {
    if (!onGround)
        landed = true;
    
    if (landed)
        with (platformTarget) other.vy = 0;
    else
        with (platformTarget) other.vy = 0;
}

repeat(abs(vx)) {
    if (place_meeting(x + sign(vx), y, oParSolid) &amp;&amp; !place_meeting(x + sign(vx), y - 1, oParSolid))
        y -= 1;
         
    if (place_meeting(x + sign(vx), y + 2, oParSolid) &amp;&amp; !place_meeting(x + sign(vx), y + 1, oParSolid))
        y += 1;
      
    // Push block //
    if (place_meeting(x + sign(vx), y, oPushBlock)) {
        // Push slowly
        vx = clamp(vx, -1, 1);
            
        with (instance_place(x + sign(vx), y, oPushBlock)) {
            // UP slope
            if (place_meeting(x + sign(other.vx), y, oParSolid) &amp;&amp; !place_meeting(x + sign(other.vx), y - 1, oParSolid))
                --y;
            
            // DOWN slope
            if (!place_meeting(x + sign(other.vx), y, oParSolid) &amp;&amp; !place_meeting(x + sign(other.vx), y + 1, oParSolid) &amp;&amp; place_meeting(x + sign(other.vx), y + 2, oParSolid))
                ++y;        

            if (!place_meeting(x + sign(other.vx), y, oParSolid))
                x += sign(other.vx); 
            else {
                other.h = 0;
                break;
            }        
        }
    } // End push block //          
          
    if (!place_meeting(x + sign(vx), y, oParSolid))
        x += sign(vx);
    else
        vx = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var onGroundPrev = onGround;

event_inherited();

if (onGround &amp;&amp; !onGroundPrev) {
    for (var i = 0; i &lt; 4; ++i) {
        instance_create(x + random_range(-8, 8), y + 8 + random_range(-2, 2), oParticlePlayer);
    }
    
    xscale = 1.33;
    yscale = 0.67;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement

// Input //////////////////////////////////////////////////////////////////////

var kLeft, kRight, kDown, kJump, kJumpRelease, kAction, kBlock, tempAccel, tempFric, kLClick;

kLeft        = keyboard_check(ord('A'))  || gamepad_axis_value(0, gp_axislh) &lt; -0.4;
kRight       = keyboard_check(ord('D')) || gamepad_axis_value(0, gp_axislh) &gt;  0.4;
kDown        = keyboard_check(ord('S'))         ||gamepad_axis_value(0, gp_axislv) &gt;  0.4;

kJump        = keyboard_check_pressed(vk_space) || gamepad_button_check_pressed(0, gp_face1);
kJumpRelease = keyboard_check_released(vk_space)|| gamepad_button_check_released(0, gp_face1);

kAction      = mouse_check_button_pressed(mb_left) || gamepad_button_check_pressed(0, gp_face3);
kDash        = keyboard_check(vk_shift)         || gamepad_button_check_pressed(0, gp_face4);

kBlock       = keyboard_check(ord('C'))         || gamepad_button_check(0, gp_face2);

//Ability part 1 and part 2
kAbility1M      = mouse_check_button_pressed(mb_right);
kAbility1GP     = gamepad_button_check_pressed(0, gp_shoulderlb);
kAbility2      = keyboard_check(ord('S')) || gamepad_button_check_pressed(0, gp_shoulderrb);

dbgClick = gamepad_button_check_pressed(0, gp_padd) || keyboard_check(vk_left);
dbg2Click = gamepad_button_check_pressed(0, gp_padu)|| keyboard_check(vk_right);


//////////////////////////////// Movement ///////////////////////////////////////////


if (dbgClick) {
    room_goto(room2)
}

if (dbg2Click) {
    room_goto(room1)
}

// Apply the correct form of acceleration and friction
if (onGround) {  
    tempAccel = groundAccel;
    tempFric  = groundFric;
    jumpCount = 2;
} else {
    if(cLeft||cRight)
    {
        jumpCount = 2;
    }
    tempAccel = airAccel;
    tempFric  = airFric;
}

// Reset wall cling
//If not touching a block to the left the right or on the ground
if ((!cRight &amp;&amp; !cLeft) || onGround) {
    canStick = true;
    sticking = false;
}   

// Cling to wall
//Player will cling to wall a certan amount of time after they hold away from the wall if they are not touching the ground
//When against a wall and holding key away from the wall
//Check if player can stick to the wall and is not on ground
//If they can stick to the wall set the wall sticking timer.
if (((kRight &amp;&amp; cLeft) || (kLeft &amp;&amp; cRight)) &amp;&amp; canStick &amp;&amp; !onGround) {
    alarm[0] = clingTime;
    sticking = true; 
    canStick = false;       
}

// Handle gravity
if (!onGround) {
    if ((cLeft || cRight) &amp;&amp; vy &gt;= 0) { //If touching a wall and not sliding up
        // Wall slide
        vy = Approach(vy, vyMax, gravSlide);
    } else {
        // Fall normally
        vy = Approach(vy, vyMax, gravNorm);
    }
}

if (state != DASH) {
    // Left 
    if (kLeft &amp;&amp; !kRight &amp;&amp; !sticking) 
    {
        facing = -1;
        state  = RUN;
        
        // Apply acceleration left
        // If x velocity is moving in opposite direction 
        // approach 0 xvelocity and approach max x velocity for moving left
        if (vx &gt; 0)
            vx = Approach(vx, 0, tempFric);   
            vx = Approach(vx, -vxMax, tempAccel);
    }
    
    // Right
    else if (kRight &amp;&amp; !kLeft &amp;&amp; !sticking)   
    {
        facing = 1;
        state  = RUN;
        
        // Apply acceleration right
        if (vx &lt; 0)
            vx = Approach(vx, 0, tempFric);   
            vx = Approach(vx, vxMax, tempAccel);
    }
}

// Friction
// If right or left keys are not pressed
if (!kRight &amp;&amp; !kLeft) {
    
    vx = Approach(vx, 0, tempFric); //Approach 0 x velocity
    
    //If we are not rolling we are idle
    if (state != DASH)
        state = IDLE;
} 
       
// Wall jumping

if (kJump &amp;&amp; cLeft &amp;&amp; !onGround) {
    yscale = 1.33;
    xscale = 0.67;
            
    if (kLeft) {
        vy = -jumpHeight * 1.2;
        vx =  jumpHeight * .66;
        audio_play_sound(sn_jump, 10, false);
    } else {
        vy = -jumpHeight * 1.1;
        vx =  vxMax; 
        audio_play_sound(sn_jump, 10, false);
    }  
}

if (kJump &amp;&amp; cRight &amp;&amp; !onGround) {
    yscale = 1.33;
    xscale = 0.67;
    
    if (kRight) {
        vy = -jumpHeight * 1.2;
        vx = -jumpHeight * .66;
        audio_play_sound(sn_jump, 10, false);
    } else {
        vy = -jumpHeight * 1.1;
        vx = -vxMax;
        audio_play_sound(sn_jump, 10, false);
    }  
}
 
// Jump
if (kJump)
{ 
    if (onGround) 
    {
        // Fall thru platform
        if (kDown) 
        {
            if (place_meeting(x, y + 1, oParJumpThru))
                ++y;
        } 
        else if(jumpCount &gt; 0) 
        {
            vy = -jumpHeight;
            yscale = 1.33;
            xscale = 0.67;
            jumpCount--;
            audio_play_sound(sn_jump, 10, false);
        }
    }
    else if(!onGround &amp;&amp; jumpCount &gt; 0)
    {
        vy = -jumpHeight;
        yscale = 1.33;
        xscale = 0.67;
        jumpCount--;
        audio_play_sound(sn_jump, 10, false);
    }
// Variable jumping
} 
else if (kJumpRelease) 
{ 
    if (vy &lt; 0)
        vy *= 0.25;
}

// Jump state
if (!onGround &amp;&amp; state != DASH)
    state = JUMP;
// Run particles
else if (random(100) &gt; 85 &amp;&amp; abs(vx) &gt; 0.5)
    instance_create(x, y + 8, oParticlePlayer);

// Swap facing during wall slide
if (cRight &amp;&amp; !onGround)
    facing = -1;
else if (cLeft &amp;&amp; !onGround)
    facing = 1;

//// DASHING ////

if(!attacking)
{
    if((kDash &amp;&amp; dashOnCD = false))
    {
        vx = 0;
        state = DASH;
        dashOnCD = true;
        alarm[2] = 60;
        vx = facing * 20.00;    
        alarm[3] = 8;
        sprite_index = sPlayerRoll;
        audio_play_sound(sn_attack, 10, false);
    }
}

if (state == DASH) {
    
    attacking = true;
        vy = 0;
}

    
// Action
if (!kBlock &amp;&amp; kAction) {
    if (!attacking) {
        // Attack out of roll
        if (onGround &amp;&amp; state == ROLL) {
            image_index  = 0;
            image_speed  = 0.5;
            sprite_index = sPlayerRollSlash;
            audio_play_sound(sn_attack, 10, false);
            
            alarm[1]  = 8; 
            attacking = true;       
        // Jab in place
        } else /*if (onGround &amp;&amp; !kRight &amp;&amp; !kLeft)*/ {
            image_index  = 0;
            image_speed  = 0.33;
            sprite_index = sPlayerJab;
            audio_play_sound(sn_attack, 10, false);
            
            attacking = true;
        }
    }
}

blocking = kBlock;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Squash + stretch

xscale = Approach(xscale, 1, 0.05);
yscale = Approach(yscale, 1, 0.05);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Abilities
//Throwing Kunai
if(kAbility1GP){

    if((!instance_exists(oAbilityKunai)) || (instance_exists(oAbilityKunai) &amp;&amp; kunai.speed &lt;= 0))
    {
         //Destory any existing Kunai
        if(instance_exists(oAbilityKunai))
            {
                with(oAbilityKunai)
                {                     
                    instance_destroy();
                }
            }   
        
        //Create new kunai
        kunai = instance_create(x, y, oAbilityKunai); 
        show_debug_message(kunai);
        
        //Get the points of the game pad
        var h_point = gamepad_axis_value(0, gp_axisrh);
        var v_point = gamepad_axis_value(0, gp_axisrv);
       
         if (h_point != 0.0 || v_point != 0.0) {
             
            pdir = point_direction(0 , 0, h_point, v_point);
            var dif = angle_difference(pdir, image_angle);
            kunai.image_angle = dif;  
     
            kunai.direction = kunai.image_angle;
            kunai.image_angle = kunai.direction;    
            kunai.speed = kunai.throwSpeed;       
            alarm[4] = throwTime;
         }    
    }
}

//Throwing Kunai
if(kAbility1M){

    //Destory any existing Kunai
    if(instance_exists(oAbilityKunai))
        {
            with(oAbilityKunai)
            {                     
                instance_destroy();
            }
        }   
        
    //Create new kunai
    kunai = instance_create(x, y, oAbilityKunai); 
    
    dir = point_direction(x , y, mouse_x, mouse_y);
    show_debug_message(dir);
    angle = degtorad(dir);
    show_debug_message(angle);
    kunai.image_angle = dir;
    kunai.direction = kunai.image_angle;
     
    kunai.speed = kunai.throwSpeed; 
}

   
//Kunai Teleport
if(kAbility2 &amp;&amp; (!kAbility1M || !kAbility1GP) &amp;&amp; instance_exists(oAbilityKunai)){ 
    
    show_debug_message("Throw")
    
    //Make sure the kunai is not currently moving
    if(kunai.speed &lt;=0) 
    {
        
        instance_create(x, y, obj_smoke);
        
        audio_play_sound(sn_poof, 10, false);
        //I cant find any easier way to initialize all these variables.
        //2 sets of varaibles are being instantiated because we will check 2 different ways
        //  of getting unstuck from the wall and choose the best option
        dir1X = kunai.x; dir2X = kunai.x;
        dir1Y = kunai.y; dir2Y = kunai.y;
        dir1C = 0; dir2C = 0; //Counters
        
        //If the player will end up stuck in a solid wall when teleported 
        if(place_meeting(kunai.x, kunai.y, oParSolid)) 
        {
            //Adjust the teleport position until this is not true
            while(place_meeting(dir1X, dir1Y, oParSolid))
            {
                dir1X += sign(x - dir1X);
                dir1Y += sign(y - dir1Y); 
                dir1C += 1;
            }
            
            while(place_meeting(dir2X, dir2Y, oParSolid))
            {
                dir2X -= sign(x - dir2X);
                dir2Y -= sign(y - dir2Y); 
                dir2C += 1;
            }            
        }
        
        //Choose the best option (the one with the least amount of adjustments to become unstuck)
        if (dir1C &lt;= dir2C)
        {x = dir1X; y = dir1Y;}
        else
        {x = dir2X; y = dir2Y;}
        instance_create(x, y, obj_smoke);
            
        //Delete the kunai object after the teleport
        if(instance_exists(oAbilityKunai))
        {
            with(oAbilityKunai)                 
                instance_destroy();
            kunai = null;  
        }   
    }   
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Hitbox

//Destory all hitboxes
with (oPlayerAtkBox)
    instance_destroy();

// Dash out of roll
if (sprite_index == sPlayerRoll) {    
    with (instance_create(x, y, oPlayerAtkBox)) {
        bboxleft  = min(other.x + (24 * other.facing), other.x + (108 * other.facing));
        bboxright = max(other.x + (24 * other.facing), other.x + (108 * other.facing));
        
        bboxtop    = other.y - 12;
        bboxbottom = other.y + 24; 
    }
}
    
// Jab
if (sprite_index == sPlayerJab &amp;&amp; round(image_index) &gt; 0) {    
    with (instance_create(x, y, oPlayerAtkBox)) {
        bboxleft  = min(other.x + (24 * other.facing), other.x + (108 * other.facing));
        bboxright = max(other.x + (24 * other.facing), other.x + (108 * other.facing));
        
        bboxtop    = other.y - 12;
        bboxbottom = other.y + 12; 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (sprite_index == sPlayerJab)
    attacking = false;
    
if (sprite_index == sPlayerRoll) {
    attacking = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
instance_destroy();   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw sprite depending on player state
if (!attacking) {
    switch (state) {
        case IDLE: 
            image_speed = 0.2;
            
            if (blocking)
                sprite_index = sPlayerIdleShield;
            else
                sprite_index = sPlayerIdle;
        break;
        
        case RUN: 
            image_speed = 0.33; 
            
            if (blocking)
                sprite_index = sPlayerRunShield;
            else
                sprite_index = sPlayerRun;
        break;
        
        case JUMP:
            // Mid jump   
            if (!(place_meeting(x, y + 2, oParSolid) &amp;&amp; vy != 0) &amp;&amp; vy &gt;= -1.0 &amp;&amp; vy &lt;= 1.0) {  
                if (blocking)
                    sprite_index = sPlayerJumpMShield;
                else
                    sprite_index = sPlayerJumpM;  
           } else { 
                // Rise + fall
                if (vy &lt;= 0) {
                    if (blocking)
                        sprite_index = sPlayerJumpUShield;
                    else  
                        sprite_index = sPlayerJumpU;  
                } else {
                    if (blocking)
                        sprite_index = sPlayerJumpDShield;
                    else
                        sprite_index = sPlayerJumpD;
                }
            }
             
            // When against a wall   
            if (cRight || cLeft)
                if (blocking)
                    sprite_index = sPlayerSlideShield;
                else
                    sprite_index = sPlayerSlide;  
        break;
        
        case ROLL:
            // Don't do stuff here    
        break;
    }
}

// Draw player
if (onGround)
    draw_sprite_ext(sprite_index, image_index, x, y + (16 - 16 * yscale) * 0.25, facing * xscale, yscale, 0, c_white, image_alpha);    
else
    draw_sprite_ext(sprite_index, image_index, x, y, facing * xscale, yscale, 0, c_white, image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,0</point>
    <point>32,32</point>
    <point>0,32</point>
  </PhysicsShapePoints>
</object>
